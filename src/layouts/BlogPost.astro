---
import type { CollectionEntry } from 'astro:content'
import FormattedDate from '@/components/FormattedDate'
import BaseLayout from '@/layouts/BaseLayout'
import Tag from '@/components/Tag'
import type { MarkdownHeading } from 'astro'
import { Image } from 'astro:assets'
import ListRelatedPosts from '@/components/ListRelatedPosts' // Añadir esta importación

type Props = {
    data: CollectionEntry<'blog'>['data']
    headings: MarkdownHeading[]
    readTime: string
    relatedPosts?: CollectionEntry<'blog'>[] // Añadir esta prop
}

const { data, readTime, headings, relatedPosts = [] } = Astro.props
const { title, description, pubDate, updatedDate, heroImage, tags } = data
const articleDate = pubDate.toISOString()
---

<BaseLayout
    title={title}
    description={description}
    image={heroImage?.src}
    articleDate={articleDate}>
    <article class='md:py-4 max-w-xs sm:max-w-none md:max-w-none'>
        <!-- Header y contenido existente -->
        <header>...</header>
        <div class='relative'>...</div>
        {updatedDate && ...}
        <hr />

        <div class="mb-16"> <!-- Añadido margen inferior -->
            <slot />
        </div>

        <!-- Sección de artículos relacionados -->
        {relatedPosts.length > 0 && (
            <div class="mt-16 pt-8 border-t dark:border-gray-800">
                <h2 class="text-2xl font-bold mb-8">Artículos Relacionados</h2>
                <ListRelatedPosts posts={relatedPosts} />
            </div>
        )}
    </article>
</BaseLayout>

<script is:inline>
	const img = document.querySelector('img')
	const placeholder = document.querySelector('.placeholder')

	img?.addEventListener('load', () => {
		img.classList.add('opacity-100')
		placeholder.classList.add('opacity-0')
	})
</script>

<script>
	import { animate } from 'motion'

	animate(
		'.title',
		{
			opacity: [0, 1],
			clipPath: ['polygon(0 0, 0 0, 0 100%, 0% 100%)', 'polygon(100% 0, 0 0, 0 100%, 100% 100%)']
		},
		{ duration: 1, easing: 'ease-in-out' }
	)
</script>

<script>
	function handleIntersection(
		entries: IntersectionObserverEntry[],
		observer: IntersectionObserver
	) {
		entries.forEach((entry) => {
			const index = document.querySelector(`aside a[href="#${entry.target.id}"]`)

			if (entry.isIntersecting) {
				index?.classList.remove('bg-slate-200', 'dark:bg-slate-800') // remove bg
				index?.classList.add(
					'bg-indigo-600',
					'dark:bg-indigo-700',
					'text-white',
					'font-bold',
					'transition-colors',
					'duration-200'
				)
			} else {
				index?.classList.add('bg-slate-200', 'dark:bg-slate-800') // add bg
				index?.classList.remove(
					'bg-indigo-600',
					'dark:bg-indigo-700',
					'text-white',
					'font-bold',
					'transition-colors',
					'duration-200'
				)
			}
		})
	}

	const headings = document.querySelectorAll(
		'div.prose h1, div.prose h2, div.prose h3, div.prose h4, div.prose h5, div.prose h6'
	)

	const options = {
		root: null,
		rootMargin: ' 15% 0px 0% 0px ',
		threshold: 1
	}

	const observer = new IntersectionObserver(handleIntersection, options)

	headings.forEach((heading) => {
		observer.observe(heading)
	})
</script>
